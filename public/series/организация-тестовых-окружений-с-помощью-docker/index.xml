<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Организация-Тестовых-Окружений-С-Помощью-Docker on Dev notes </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://dddpaul.github.io/series/d0bed180d0b3d0b0d0bdd0b8d0b7d0b0d186d0b8d18f-d182d0b5d181d182d0bed0b2d18bd185-d0bed0bad180d183d0b6d0b5d0bdd0b8d0b9-d181-d0bfd0bed0bcd0bed189d18cd18e-docker/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Thu, 08 Jan 2015 13:49:06 UTC</updated>
    
    <item>
      <title>Связывание контейнеров</title>
      <link>http://dddpaul.github.io/blog/2015/01/08/docker-test-env-2/</link>
      <pubDate>Thu, 08 Jan 2015 13:49:06 UTC</pubDate>
      
      <guid>http://dddpaul.github.io/blog/2015/01/08/docker-test-env-2/</guid>
      <description>&lt;p&gt;При создании тестовых окружений из нескольких контейнеров неизбежно возникает задача их взаимного связывания. Набивший оскомину пример: контейнеру с приложением нужен контейнер БД. В нашем же случае, контейнеру с балансером нужны контейнеры с апстримами.&lt;/p&gt;

&lt;p&gt;Статья &lt;a href=&#34;https://docs.docker.com/userguide/dockerlinks/&#34;&gt;Linking Containers Together&lt;/a&gt; полностью раскрывает вопрос линковки контейнеров. Осветим вкратце лишь основные моменты:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;каждый контейнер необходимо как-то назвать с помощью опции &lt;code&gt;--name&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;ссылка на контейнер-зависимость обозначается опцией &lt;code&gt;--link&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;в итоге, внутри зависимого контейнера, инициализируется множество переменных окружения, содержащих параметры контейнера-зависимости, а также в &lt;em&gt;/etc/hosts&lt;/em&gt; заносится IP-адрес контейнера-зависимости.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Например, так выглядит последовательный запуск 3-х контейнеров, причем 3-й зависит от первых двух:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d --privileged -p 2021:22 -p 8081:80 --name app1 smile/tomcat7
docker run -d --privileged -p 2022:22 -p 8082:80 --name app2 smile/tomcat7
docker run -d --privileged -p 2020:22 -p 80:80 --name gate --link app1:app1 --link app2:app2 smile/gate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Опция &lt;code&gt;-d (detach mode)&lt;/code&gt; здесь необходима, чтобы контейнеры запускались в фоновом режиме и не захватывали консоль.&lt;/p&gt;

&lt;p&gt;Теперь, если зайти в контейнер gate (&lt;code&gt;ssh -p 2020 root@localhost&lt;/code&gt;) и посмотреть переменные окружения, то будет ясно, что gate &amp;ldquo;видит&amp;rdquo; exposed-порты и IP-адрес контейнера-зависимости:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@aba982937531:~# env | grep APP1
APP1_NAME=/gate/app1
APP1_PORT_22_TCP=tcp://172.17.0.28:22
APP1_PORT_80_TCP=tcp://172.17.0.28:80
APP1_PORT_22_TCP_ADDR=172.17.0.28
APP1_PORT_80_TCP_ADDR=172.17.0.28
APP1_PORT_22_TCP_PORT=22
APP1_PORT_80_TCP_PORT=80
APP1_PORT_80_TCP_PROTO=tcp
APP1_PORT_22_TCP_PROTO=tcp
APP1_PORT=tcp://172.17.0.28:22
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Еще лучше дела обстоят с &lt;em&gt;/etc/hosts&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@aba982937531:~# grep app1 /etc/hosts
172.17.0.28	app1

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Модификация &lt;em&gt;/etc/hosts&lt;/em&gt;, например, дает возможность писать следующие кофиги Nginx:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
    listen 80 default_server;
    server_name _;

    location /app1 {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #
        proxy_pass http://app1:80/app1;                              # app1 host here
        proxy_redirect http://127.0.0.1:8081/app1 /app1;             #
    }

    location /app2 {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #
        proxy_pass http://app2:80/app2;                              # and app2 host here
        proxy_redirect http://127.0.0.1:8082/app2 /app2;             #
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Таким образом, в первом приближении, встроенная возможность связывания контейнеров в Docker решает наши проблемы.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Подготовка и запуск docker-контейнеров</title>
      <link>http://dddpaul.github.io/blog/2015/01/04/docker-test-env-1/</link>
      <pubDate>Sun, 04 Jan 2015 13:49:06 UTC</pubDate>
      
      <guid>http://dddpaul.github.io/blog/2015/01/04/docker-test-env-1/</guid>
      <description>

&lt;p&gt;Сразу оговорюсь, что все docker-контейнеры основаны на &lt;a href=&#34;http://phusion.github.io/baseimage-docker/&#34;&gt;baseimage-docker&lt;/a&gt;. Этот образ позволяет запускать в контейнере несколько приложений с помощью супервизора &lt;a href=&#34;http://smarden.org/runit/&#34;&gt;runit&lt;/a&gt; и содержит ssh, cron, syslog &amp;ldquo;из коробки&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Хотя подобный подход &lt;a href=&#34;http://jpetazzo.github.io/2014/06/23/docker-ssh-considered-evil/&#34;&gt;не рекомендуется разработчиками Docker&lt;/a&gt;, он очень удобен в эксплуатации и не принуждает разработчика к своему &amp;ldquo;proper way&amp;rdquo;. Всегда можно использовать канонический подход от Docker с volumes и nsenter, а, при желании, подключаться к контейнерам по ssh.&lt;/p&gt;

&lt;p&gt;Кроме того, я привык использовать сервера приложений в связке с nginx, и baseimage-docker позволяет легко это сделать.&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;Базовый образ&lt;/h3&gt;

&lt;p&gt;При создании базового образа выполняются две вещи:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;публичный ssh-ключ добавляется в список разрешенных для суперпользователя контейнера;&lt;/li&gt;
&lt;li&gt;задается локаль.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Dockerfile&lt;/em&gt; базового образа:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM phusion/baseimage:0.9.15

# Add public SSH keys
ADD my_rsa_public_key /tmp/my_rsa_public_key
RUN cat /tmp/my_rsa_public_key &amp;gt;&amp;gt; /root/.ssh/authorized_keys &amp;amp;&amp;amp; rm -f /tmp/my_rsa_public_key

# Locale
ENV LANG=en_US.utf8

# Use baseimage-docker&#39;s init system
CMD [&amp;quot;/sbin/my_init&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Свой публичный ssh-ключ, естественно, надо положить в &lt;em&gt;my_rsa_public_key&lt;/em&gt; рядом с &lt;em&gt;Dockerfile&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Сборка: &lt;code&gt;docker build -t smile/base .&lt;/code&gt; и запуск:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm -it -p 2022:22 smile/base /sbin/my_init -- bash -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--rm&lt;/code&gt; используется для удаления контейнера после его остановки, &lt;code&gt;-it&lt;/code&gt; — для терминального интеракивного режима, а &lt;code&gt;-- bash -l&lt;/code&gt; — для запуска шелла после запуска всех сервисов.&lt;/p&gt;

&lt;p&gt;Также на контейнер можно зайти по ssh: &lt;code&gt;ssh -p 2022 root@localhost&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;Образ с nginx&lt;/h3&gt;

&lt;p&gt;Сборка &lt;a href=&#34;https://github.com/dddpaul/docker-nginx&#34;&gt;docker-nginx&lt;/a&gt;: &lt;code&gt;docker build -t smile/nginx .&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Основная особенность этого образа в том, что при запуске контейнера отключается IPv6.&lt;/p&gt;

&lt;p&gt;Сделано это для того, чтобы обойти известную проблему с проксированием Nginx. Т.к. демон висит на tcp6, то апстрим иногда видит запрос от 127.0.0.1, а иногда от 0:0:0:0:0:0:0:1. Это принуждает к изменению ACL на сервере приложений, что не всегда удобно.&lt;/p&gt;

&lt;p&gt;IPv6 отключается после выполнения серии sysctl-команд, которые требуют, чтобы контейнер был запущен в привилегированном режиме, т.е. команда запуска слегка усложняется:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --privileged --rm -it -p 2022:22 smile/nginx /sbin/my_init -- bash -l
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Остальные образы&lt;/h3&gt;

&lt;p&gt;На основе docker-nginx можно строить более сложные образы, такие как &lt;a href=&#34;https://github.com/dddpaul/docker-java7-server&#34;&gt;docker-java7-server&lt;/a&gt; и  &lt;a href=&#34;https://github.com/dddpaul/docker-tomcat7&#34;&gt;docker-tomcat7&lt;/a&gt;. На основе последнего уже строятся образы для конечных приложений.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>