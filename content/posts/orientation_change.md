+++
date = 2014-08-02T13:32:33Z
draft = false
title = "Подводные камни смены ориентации"
tags = [ "Android", "Java" ]

+++

Основная мысль, которую я вынес после нескольких дней отладки приложения: смена ориентации (rotation, orientation change) - это очень непростая вещь! Она дает просто массу способов выстрелисть себе в ногу. Наконец-то я понял, тех разработчиков, которые просто запрещают смену ориентации в своем софте.

Какие же здесь есть подводные камни?

### Beginner's level
 
 Надо сохранять состояние (state) фрагментов. Не сохранил - потерял, т.к. активити и фрагменты будут пересозданы. Если стейт фрагмента сериализуется в строку, то просто переопределяем метод onSaveInstanceState(). Способ описан как в [официальной документации](http://developer.android.com/guide/components/fragments.html#Lifecycle), так и в множестве других мест.

### Intermediate.

Не забываем про AsyncTask. Их тоже надо сохранять, ибо иначе при смене ориентации он улетит в космос как Вояджер-1. Или что-нибудь обвалит :) Для решения этой проблемы придумана такая отличная штука, как retaining fragments. Всего один вызов setRetainInstance(true) продляет жизнь фрагменту и связанному с ним асинктаску (назовем это длинный стейт).

Тут начинаются подводные камни (потому и intermediate level). Что если мы хотим в портретном режиме свайпить фрагменты (через ViewPager), а в landscape - просто показать их всех в линеечку (с помощью LinearLayout безо всякого ViewPager)? Запустим приложение в portrait mode, перевернем, и получим "IllegalArgumentException: No view found".

Суть в том, что изначальный фрагмент с портретного режима останется и даже сохранит ссылку на ViewPager, которого в landscape layout уже просто нет :) Отсюда вывод - использовать для сохранения длинного стейта нужно headless fragments, т.е. фрагменты без UI. Тогда получается красиво: в "обычных" фрагментах формочки и кнопочки, а асинктаски - в отдельных, которые ничего про UI не знают.

Остался последний вопрос - как этот headless fragment создать/запустить? В android-samples есть пример [FragmentRetainInstance.java](https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/app/FragmentRetainInstance.java), в котором используется способ матрешки - активити запускает parent fragment, parent запускает worker fragment, внутри которого сидит асинктаск.

Вроде хорошая схема, но если вы, не дай бог, возьмете Robolectric и напишите юнит-тест для родительского фрагмента, то получите что-то типа recursive transaction exception. Суть в том, что роболектрик создает тестируемый фрагмент обычным способом (через транзакцию), а внутри запускается новая транзакция (для worker fragment). А так нельзя, это вам не JPA какой-нибудь :)

Итого - держим асинктаски в headless-фрагменте, который запускаем из активити. В целом, это отличная схема на все случаи жизни, а не только для приведенного примера.

### Veteran
 
Копаем в сторону уже всколзь упомянутого multi-pane. Как его сделать правильно на одних фрагментах? Внятно описанный [способ от Ларса Вогеля](http://www.vogella.com/tutorials/AndroidFragments/article.html) требует разных активити, а я не хочу плодить сущности.

Используем уже описанный метод с двумя layout'ами (ведь мы же за декларативный подход!):

* 1-й layout состоит из одного ViewPager'а;
* 2-й - LinearLayout с двумя фрагментами.

В чем прелесть подхода - 2-й layout можно положить в папочку, например, layout-w600dp и он будет автоматически использован, если ширина экрана больше 600dp. Красота!

Оно даже работает и не падает. Правда, появился какой-то странный глюк с [EventBus](http://github.com/greenrobot/EventBus): иногда фрагмент получает два сообщения вместо одного. При более пристальном изучении оказалось наоборот - два одинаковых фрагмента получают одно сообщение. Откуда они берутся? А кто его знает :)

Убил кучу времени в DDMS, VisualVM и MAT, написал [тестовый проект](https://github.com/dddpaul/android-ViewPagerBug), описал симптомы на [StackOverflow](http://stackoverflow.com/questions/25033824/dublicate-fragment-allocation-when-using-viewpager-with-different-layouts). Вкратце, именно при использовании такого варианта multi-pane (когда в одном layout есть ViewPager, а в другом нет), фрагменты создаются ДВАЖДЫ. Причем, оба в RESUMED state, поэтому они оба и ловят сообщения по EventBus. 

Плюнув, отказался от второго layout'а, теперь ViewPager используется везде. Чтобы показать сразу 2 фрагмента, можно использовать разные [хитрые способы](http://commonsware.com/blog/2012/08/20/multiple-view-viewpager-options.html). Они, в общем, несложные, и, в моем случае, способ с переопределением getPageWidth() даже не внес никаких сайд-эффектов. Правда, определение ширины экрана, когда надо показать multi-pane пришлось вынести в код, получилось чуть менее декларативненько.

### Hardcore
 
Плавно переходим к утечкам памяти :)

Очень веселая ситуация, когда после, например, после 10 ротаций эмулятора и нескольких запусков GC в хипе болтаются 11 activities. Решив идти до конца, вооружившись методом исключения и вырезав почти весь код и вьюхи, удалось докопаться до причины. Утекал компонент TextView с опцией [textIsSelectable="true"](http://stackoverflow.com/questions/22990634/textview-with-id-and-textisselectable-true-causes-leaking-of-the-activity-obje). Очень порадовало начало топика "It took me three days to narrow my problem ..." :)
 
Убрал одну строчку в layout, утечка исчезла, ура. Вернулся в основную ветку, вставил этот коммит, прогнал тест (10 ротаций), получил 10 activities. Уже лучше :)

Оказалось, компонент EditText также замечательно утекает. Причина, вроде бы в том, что он слишком умный (у него по-умолчанию включен спеллчекер). Если отключить, то утечка может пропасть, а может и нет. Прогнал тест на разных эмуляторах, оказалось, что в 4.3 баг починен, уже хорошо! А я все тестил на 4.1.2.

Раз версия 4.3 такая замечательная, может быть, там починена утечка textIsSelectable? А то вдруг понадобится эта опция? Нет, все без изменений. Версия 4.4.2? А вот фиг вам - [баг в эмуляторе](https://code.google.com/p/android/issues/detail?id=61671). Вы не можете повернуть эмулятор с этой версией Андроида :) Тест запустить не удалось.

Фрагменты также могут утекать. В сети полно примеров организации свайпа с ViewPager (это где фрагменты создаются в классе-потомке FragmentPagerAdapter и т.д.) Все замечательно, но не забываем вставлять в onDestroy():

```
pager.removeAllViews();
pager.setAdapter( null );
```

Иначе, каждый раз при rotation старые фрагменты не будут собираться GC. Если у вас приложение с 2-мя фраментами, то после 10 ротаций будет 22, плюс 11 activities. По крайней мере, в 4.1.2. В 4.3 уже можно этим не заморачиваться :)

### Заключение

К чему весь этот пост - выложил обновление [Simple NetCat](https://play.google.com/store/apps/details?id=com.github.dddpaul.netcat). Версия 1.4 поддерживает multi-pane на планшетах, содержит меньше багов (скрестил два пальца) и практически не течет по памяти. 